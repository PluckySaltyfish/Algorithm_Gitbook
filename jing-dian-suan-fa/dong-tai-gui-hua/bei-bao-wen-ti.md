### 01背包

---

#### 问题描述

有$$N$$件物品，第$$i$$件物品的重量为$$w_{i}$$，价值为$$v_{i}$$，有一背包的容积为$$C$$，现在将物品装进背包，求在装载不超过背包容量大小的物品的最大价值。

#### 优化解法

> 注意dp一定要先初始化为0

```cpp
for (int i = 1; i <= N; i++) {
        for (int j = C; j >=w[i]; j--) {
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
```

时间复杂度$$O(CN)$$，空间复杂度$$O(C)$$。

### 完全背包

---

#### 问题描述

有$$N$$种物品，第$$i$$种物品的重量为$$w_{i}$$，价值为$$v_{i}$$，每种物品的个数都是无限的，每种可以取若干件装入背包，有一背包的容积为$$C$$，现在将物品装进背包，求在装载不超过背包容量大小的物品的最大价值。

#### 问题分析

将完全背包看作01背包来求解，则其的动态规划方程可以写成：


$$
dp[i][j]=\{ dp[i-1][j-k*w[i]]+k*v[i]|0\leq k \leq j/w[i] \}
$$


即：


$$
dp[i][j]=max\{ dp[i-1][j],dp[i-1][j-w[i]]+v[i],dp[i][j-2*w[i]]+2*v[i],... \}
$$


又因为：


$$
dp[i][j-w[i]]=max\{ dp[i-1][j-w[i]],dp[i][j-2*w[i]]+v[i],... \}
$$


可得：


$$
dp[i][j]=max\{ dp[i-1][j],dp[i][j-w[i]]+v[i] \}
$$


#### 优化解法

```cpp
    for (int i = 1; i <= N; i++) {
        for (int j = w[i]; j <= C; j++) {
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
```

与01背包相比，第二层循环的顺序变成了从小到大，这是因为要用选择当前物品的条件下较小的容量去更新较大的容量，故需要先取得较小容量的值。

时间复杂度$$O(CN)$$，空间复杂度$$O(C)$$。

